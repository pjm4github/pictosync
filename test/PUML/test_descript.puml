@startuml Architecture Diagram
!theme plain

title PokeAMI — Simulated AMI Architecture

skinparam frame {
    BackgroundColor<<sim>> #FFF8E1
    BorderColor<<sim>> #FFC107
}

' ============================================================
'  Simulation Layer
'  (generates data and controls the emulated components)
' ============================================================

frame "Simulation Layer (no real-world equivalent)" <<sim>> {

    [DataGenerator\n--\nTime-series generation\nDuck curves, seasonal patterns\nQuality injection\nSolar reverse flow\n(implements ReadingSource)] as DG

    [LoadModel (stub)\n--\nFuture physics-based\nReadingSource] as LM

    [Simulator Engine\n(facade)] as SE
    [Event Log] as EL

    frame "Control Endpoints" <<sim>> as CE {
        [/simulator/status] as SimStatus
        [/simulator/stop|start] as SimCtrl
    }

    [Dashboard\n(port 8001)] as Dash
}

' ============================================================
'  Emulated Smart Meters
'  (represent physical meter hardware in the field)
' ============================================================

node "Emulated Smart Meters" as ESM {
    [MeterPark\n--\nFleet of SmartMeter objects\n(E350/E360/S4x/E660)\nUsage points, comm modules\nweighted distribution] as MP
}

note bottom of ESM
    Each **SmartMeter** wraps a Meter object
    with a pluggable **ReadingSource**.
    MeterPark delegates reads to SmartMeters,
    which delegate to their ReadingSource.
end note

' ============================================================
'  Emulated AMI Components
'  (represent real Landis+Gyr infrastructure)
' ============================================================

cloud "Communication Network\n(emulated)" as COMM {
    [RF Mesh\n3-8 hops, 8-20s latency\n10% failure rate] as RF
    [PLC\n12-25s latency\n15% failure rate] as PLC
    [Cellular LTE\n3-8s latency\n5% failure rate] as LTE
}

node "Gridstream HES\n(Head-End System)" as HES {
    [Data Collection\n& Storage] as DC
    [Meter Inventory] as MI
}

node "Core MDMS\n(Meter Data Mgmt)" as MDM {
    [Validation]
    [Estimation]
    [Editing]
}

node "Gridstream Analytics" as GA {
    [Demand Analysis]
    [Voltage Monitoring]
    [Revenue Protection]
}

node "Delivery Manager\n(On-Demand Reads)" as DM {
    [Promise Tracking] as PT
    [Comm Latency &\nFailure Simulation] as CLS
}

node "REST API\n(FastAPI + OpenAPI 3.1)\nport 8000" as API {
    [/meters]
    [/readings]
    [/usage-points]
    [/reading-types]
    [/analytics]
    [/delivery-promises]
}

actor "Client Applications" as Client

' ============================================================
'  ReadingSource: simulation layer → emulated meters
' ============================================================

DG -down-> MP : <<ReadingSource>>\ngenerates readings\n(energy, demand,\nvoltage, quality)
LM .down.> MP : <<ReadingSource>>\n(future)

' ============================================================
'  Data flow: meters → comm network → HES
' ============================================================

MP -down-> COMM : meter fleet\n(objects + config)

COMM -down-> HES : bulk collection\n(startup)

' ============================================================
'  On-demand read flow
'  Client → API → Delivery Manager → HES → Comm Network
'  → SmartMeter (ReadingSource) → Comm Network → HES → response
' ============================================================

DM -up-> HES : 1. request\non-demand read
HES -up-> COMM : 2. route to meter\nvia comm path
COMM -up-> MP : 3. SmartMeter produces\nfresh reading
COMM -down-> HES : 4. reading returns\n(with latency + possible failure)
HES -down-> DM : 5. deliver collected\nreadings

note right of DM
    **On-demand read lifecycle:**
    1. Delivery Manager asks HES to read a meter
    2. HES routes through the comm network
    3. SmartMeter produces a reading via ReadingSource
    4. Response traverses back with simulated
       latency and failure rate per comm type
    5. HES delivers collected data to the promise
    COMM_FAILURE meters: 80% failure rate
end note

' ============================================================
'  Emulated AMI data flow (historical/batch)
' ============================================================

HES -down-> MDM : raw readings
HES -down-> GA : raw data
MDM -down-> GA : validated data

HES --> API
MDM --> API
GA --> API
DM --> API

Client --> API : HTTP + X-API-Key

' ============================================================
'  Simulation control flow
' ============================================================

SE ..> HES : wraps
SE ..> MDM : wraps
SE ..> GA : wraps
SE ..> DM : wraps
SE ..> MP : wraps
SE ..> DG : wraps
SE ..> COMM : wraps

SimCtrl ..> SE : stop/start\ncomponents
SimStatus ..> SE : poll status
SimStatus ..> EL : read events
SimCtrl ..> EL : log events

Dash --> SimStatus : poll
Dash --> SimCtrl : control
Dash --> API : fetch data

@enduml
